Detect Cycle in a ll :
    For detecting  cycle in a linked list, we take two pointers from the head position of a linked list. Give one 
    double the speed of normal pointer. If later, they point to the same node then they are in a cycle as in a 
    linear list they would not have met. Value of a node can be same but the exact node pointer cannot be same.

Recursive insertion in a ll :
    

Happy Number : Square of Digits eventually equal to 1
    Ek function to alag se hoga hi, square of digits nikalne ke liye. Isse agla num milega. Use floyd's algo.
    If fast pointer is equal to the slow pointer, then values are repeating and we are repeating in a loop, so 
    then we compare if we are repeating at value '1'. If yes then 'OK' or else.

Middle of a ll :
    Take two pointers ( slow and fast ), and make them traverse the list. Fast travels two times slow. So when 
    fast reaches end, low is halfway there ( middle ).

Reverse a ll :
    Well, for this we need three pointers. Initially prev is null and curr is at head. Then, we traverse curr 
    over the LL ( creating next node [ next = curr.next ]) until it is null( prev is at the last[now first] node). 
    Logic: connect curr to prev, prev becomes curr and curr becomes next.

Add Two Numbers:
    Two LL heads given(at ones place of the digit). Well, add both nodes and then '%' 10 to get value and add to 
    the total value of node. '/' by 10 to get the carry value. If in the end carry is not zero, then add a node 
    with the left value.